Three-Tier Web Application on Azure Kubernetes Service (AKS)
A complete React + Node.js + MongoDB three-tier cloud-native application deployed on Azure Kubernetes Service (AKS) using:

âœ… Docker (ARM â†’ AMD64) âœ… Azure Container Registry (ACR) âœ… Kubernetes Deployments & Services âœ… NGINX Ingress Controller âœ… MongoDB Atlas âœ… Terraform (for AKS creation)

This guide contains all steps we executed end-to-end.

âœ… Architecture Overview
React (Frontend)
       â”‚
Ingress (NGINX)
       â”‚
/ â†’ Frontend Service â†’ Frontend Pods
/api â†’ Backend Service â†’ Backend Pods â†’ MongoDB Atlas
âœ… Step 1 â€” Install Docker & Enable Daemon
Install Docker Desktop on macOS
Start Docker daemon:
docker ps
If daemon not running:

sudo systemctl start docker   # Linux
âœ… Step 2 â€” Start Jenkins (optional for CI/CD)
docker pull jenkins/jenkins:lts
If error:

Cannot connect to the Docker daemon
â†’ Start Docker.

âœ… Step 3 â€” Create 3-Tier Application
âœ… Tech Stack Selected
Frontend: React
Backend: Node.js + Express
Database: MongoDB Atlas
DevOps Tools: Docker, Kubernetes, Azure
âœ… Step 4 â€” Create Backend
Folder Structure
backend/
  â”œâ”€â”€ server.js
  â”œâ”€â”€ package.json
  â”œâ”€â”€ Dockerfile
server.js Example
const express = require("express");
const mongoose = require("mongoose");
const app = express();
app.use(express.json());

app.get("/api/health", (req, res) => {
  res.json({ status: "OK âœ…", mongo: mongoose.connection.readyState });
});

app.get("/api/messages", async (req, res) => {
  const msgs = await Message.find();
  res.json(msgs);
});

app.post("/api/messages", async (req, res) => {
  const msg = await Message.create({ text: req.body.text });
  res.json(msg);
});

mongoose.connect(process.env.MONGO_URL).then(() => {
  console.log("âœ… MongoDB connected");
  app.listen(5000, () => console.log("ðŸš€ Backend running at http://localhost:5000"));
});
Dockerfile
FROM node:18
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 5000
CMD ["npm", "start"]
âœ… Step 5 â€” Create Frontend
frontend/
  â”œâ”€â”€ src/App.jsx
  â”œâ”€â”€ Dockerfile
Updated App.jsx
Uses relative paths for Kubernetes:

fetch("/api/messages")
Dockerfile
FROM node:18-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80
âœ… Step 6 â€” Create MongoDB Atlas Cluster
Create project in MongoDB Atlas

Whitelist:

Local IP for initial dev
Later, AKS outbound public IP
Create database user

Copy connection string â†’ MONGO_URL

âœ… Step 7 â€” Build AMD64 Images (for AKS)
Mac M1/M2 builds ARM images â†’ AKS needs AMD64.

docker buildx create --use

# Backend
docker buildx build --platform linux/amd64 -t 3tieracr.azurecr.io/backend-app:v1 --push .

# Frontend
docker buildx build --platform linux/amd64 -t 3tieracr.azurecr.io/frontend-app:v1 --push .
âœ… Step 8 â€” Create Azure Resources Using Terraform
main.tf
Includes:

Resource Group
ACR
AKS
terraform init
terraform apply
âœ… Step 9 â€” Give AKS Access to ACR
az aks update --resource-group three-tier-rg --name three-tier-aks --attach-acr 3tieracr
âœ… Step 10 â€” Connect kubectl to AKS
az aks get-credentials -g three-tier-rg -n three-tier-aks
âœ… Step 11 â€” Create Namespace
kubectl create namespace three-tier
âœ… Step 12 â€” Store MongoDB URL in Kubernetes Secret
kubectl create secret generic mongodb-secret \
  --from-literal=MONGO_URL="<mongo-url>" \
  -n three-tier
âœ… Step 13 â€” Deploy Backend
backend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: three-tier
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: 3tieracr.azurecr.io/backend-app:v2
        env:
        - name: MONGO_URL
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: MONGO_URL
        ports:
        - containerPort: 5000
---
apiVersion: v1
kind: Service
metadata:
  name: backend-svc
  namespace: three-tier
spec:
  selector:
    app: backend
  ports:
  - port: 5000
    targetPort: 5000
  type: ClusterIP
Apply:

kubectl apply -f backend.yaml
âœ… Step 14 â€” Deploy Frontend
frontend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: three-tier
spec:
  replicas: 1
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: 3tieracr.azurecr.io/frontend-app:v3
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-svc
  namespace: three-tier
spec:
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
Apply:

kubectl apply -f frontend.yaml
âœ… Step 15 â€” Install NGINX Ingress Controller
kubectl create namespace ingress-nginx
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm install nginx-ingress ingress-nginx/ingress-nginx -n ingress-nginx --set controller.publishService.enabled=true
âœ… Step 16 â€” Create Ingress
ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: three-tier-ingress
  namespace: three-tier
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$1
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /api/?(.*)
        pathType: Prefix
        backend:
          service:
            name: backend-svc
            port:
              number: 5000
      - path: /(.*)
        pathType: Prefix
        backend:
          service:
            name: frontend-svc
            port:
              number: 80
Apply:

kubectl apply -f ingress.yaml
âœ… Step 17 â€” Get Public IP
kubectl get svc -n ingress-nginx
Open in browser:

http://<public-ip>/
http://<public-ip>/api/health
âœ… Step 18 â€” Final Working App ðŸŽ‰
âœ… Frontend loads âœ… Backend health OK âœ… MongoDB connected âœ… Messages can be created/read âœ… Fully working end-to-end application âœ… Production-ready cloud-native deployment

âœ… Enhancements (Next Steps)
Add Jenkins or GitHub Actions CI/CD
Add HPA (Horizontal Pod Autoscaler)
Add HTTPS via cert-manager + Letâ€™s Encrypt
Add Azure Key Vault for secrets
Add Terraform for full infra automation
âœ… Author
Preetham Darshanala DevOps Engineer | Cloud | Kubernetes | CI/CD | Azure

âœ… End of Project â€” Congratulations ðŸŽ‰
You completed a full production-level 3-tier deployment on AKS!
